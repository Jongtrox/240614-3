<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Moving Alien in Space</title>
</head>
<body>
  <canvas id="spaceCanvas" width="400" height="400"></canvas>

  <script>
    const canvas = document.getElementById('spaceCanvas');
    const ctx = canvas.getContext('2d');

    // Colors
    const BLACK = '#000';
    const WHITE = '#fff';
    const GREEN = '#0f0';
    const GRAY = '#888';

    // Star class (unchanged)
    class Star {
      constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.radius = Math.random() * 1.5;
        this.alpha = Math.random();
        this.alphaChange = 0.02;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
        ctx.fill();
      }

      update() {
        this.alpha += this.alphaChange;
        if (this.alpha > 1 || this.alpha < 0) {
          this.alphaChange *= -1;
        }
      }
    }

    // UFO class
    class UFO {
      constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.size = 100;
        this.speed = 3;
        this.moveX = 0;
        this.moveY = 0;
        this.rotation = 0;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        // UFO body
        ctx.fillStyle = GRAY;
        ctx.beginPath();
        ctx.ellipse(0, 0, this.size, this.size / 2, 0, 0, Math.PI * 2);
        ctx.fill();

        // UFO window
        ctx.fillStyle = GREEN;
        ctx.beginPath();
        ctx.ellipse(0, 0, this.size / 2, this.size / 4, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      update() {
        this.x += this.moveX * this.speed;
        this.y += this.moveY * this.speed;

        // Keep UFO within canvas bounds
        this.x = Math.max(this.size / 2, Math.min(this.x, canvas.width - this.size / 2));
        this.y = Math.max(this.size / 2, Math.min(this.y, canvas.height - this.size / 2));

        // Rotate UFO based on movement direction
        if (this.moveX !== 0 || this.moveY !== 0) {
          this.rotation = Math.atan2(this.moveY, this.moveX);
        }
      }
    }

    // Updated Alien class
    class Alien {
      constructor() {
        this.baseSize = 30;
        this.size = this.baseSize;
        this.speed = 3;
        this.eyeOpen = true;
        this.blinkInterval = Math.random() * 2000 + 1000; // 1-3 seconds
        this.antennaDegree = 0;
        this.pulseDirection = 1;
        this.lastBlink = 0;
      }

      draw(x, y) {
        this.x = x;
        this.y = y;

        // Pulsating body
        ctx.fillStyle = GREEN;
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, this.size / 2, this.size / 1.5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Blinking eyes
        if (this.eyeOpen) {
          ctx.fillStyle = WHITE;
          ctx.beginPath();
          ctx.arc(this.x - this.size / 4, this.y - this.size / 4, this.size / 8, 0, Math.PI * 2);
          ctx.arc(this.x + this.size / 4, this.y - this.size / 4, this.size / 8, 0, Math.PI * 2);
          ctx.fill();
        }

        // Wobbling antenna
        ctx.save();
        ctx.translate(this.x, this.y - this.size / 2);
        ctx.rotate(Math.sin(this.antennaDegree) * 0.2);
        ctx.strokeStyle = GREEN;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, -this.size / 2);
        ctx.stroke();

        ctx.fillStyle = GREEN;
        ctx.beginPath();
        ctx.arc(0, -this.size / 2, this.size / 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      update(deltaTime) {
        // Blink eyes
        if (deltaTime - this.lastBlink > this.blinkInterval) {
          this.eyeOpen = !this.eyeOpen;
          this.lastBlink = deltaTime;
          this.blinkInterval = Math.random() * 2000 + 1000;
        }

        // Wobble antenna
        this.antennaDegree += 0.05;

        // Pulsate body
        this.size += 0.1 * this.pulseDirection;
        if (this.size > this.baseSize + 5 || this.size < this.baseSize - 5) {
          this.pulseDirection *= -1;
        }
      }
    }

    // Create objects
    const stars = Array.from({ length: 100 }, () => new Star());
    const ufo = new UFO();
    const alien = new Alien();

    // Handle key events
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') {
        ufo.moveX = -1;
      }
      if (e.key === 'ArrowRight') {
        ufo.moveX = 1;
      }
      if (e.key === 'ArrowUp') {
        ufo.moveY = -1;
      }
      if (e.key === 'ArrowDown') {
        ufo.moveY = 1;
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        ufo.moveX = 0;
      }
      if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        ufo.moveY = 0;
      }
    });

    // Animation loop
    let lastTime = 0;
    function animate(currentTime) {
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;

      ctx.fillStyle = BLACK;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      stars.forEach(star => {
        star.draw();
        star.update();
      });

      ufo.update();
      ufo.draw();

      // Draw alien on top of the UFO
      alien.update(deltaTime);
      alien.draw(ufo.x, ufo.y - ufo.size / 2);

      requestAnimationFrame(animate);
    }

    animate(0);
  </script>
</body>
</html>
